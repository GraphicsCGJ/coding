###기록용
* dfs의 메모리문제가 발생할 수 있다.
    * dfs는 구현이 편리하지만 재귀호출로 사용하면 계속해서 activation record가 쌓일 수 있다.
    * 이로인해 코딩테스트 시에는 메모리 문제가 발생할 수 있음을 유의하자.

* 백트래킹 알고리즘은 웬만하면..
    * void backtracking 이라는 함수가 있다손 치면
        * 함수 초입에 조건문을 다 때려박고 ( 완료조건 및 예외조건 다 )
        * 함수 내부에는 노드를 넣을 것인지 말 것인지만 짜자
        * 경험상 이게 제일 간단한 것 같다.

* dfs/bfs queue사용 시,
   * 방문할 노드를 미리 기록하기 때문에, 방문 시에 visited를 체크하게 되면, 중복 방문으로 인한 무한루프에 빠질 수 있다.
   * 따라서 방문할 노드에 대해선 어차피 방문할 것이므로(큐에 이미 올라감), visited를 미리 체크하자
    * 이거 중요하다!

* 순열
    * next_permutation은 순열
    * 조합을 찾을 땐 1, 1, 0, 0 등으로 1에 해당하는게 선택이라 생각하면 된다.
* backtracking
    * 14500_failed  코드 자주 보자. ( 테트로미노 )
        * 백트래킹으로 풀 수 있나? 시간 제한 고려하면 struct 미리 정의해서 미는게 나을 것 같다.
        * set 의 comparator 관련 내용 들어가있음.
        * n * m의 상수시간 해결이 훨씬 쉬운 이유.
        * visited를 쓰는 케이스와, 예외처리에 대해서 brute force하게 해결하는 방법 생각해내기.

* cpp comparator 관련 내용 나중에 정리해보자.
    * https://stackoverflow.com/questions/2620862/using-custom-stdset-comparator

* vector reserve!
    * 미리 공간 할당 받아서 사용.
        * backtracking 시, vector로 push pop한다면, 공간을 애초에 하나를 받아서 사용해라. ( max size 안다면 )
        * 반복해서 사용할 경우 전역에다 vector 선언하는게 낫다.
            * reserve 없이 사용하면 새로운 메모리 만나게 될 시, vector 메모리 전체 copy가 일어난다. 만약 이게 반복된다면? 계속해서 push마다 full copy가 발생.
    * 따라서 코테에선 전역변수를 최대한 활용해야 하고, 메모리 할당을 받아놓을 수 있으면 받아놓고 수행하는게 훨씬 빠르다.
        14500 case에선 10배이상 차이남 ( 시간 초과 2초에 걸리기 때문 )

* 10971 TSP
    * 내코드 좀더 다듬으면서 백트래킹 확실하게 다져놓자.

* 한 번에 짜는 연습을 하자.
    * 범위 등 전부 다 확실하게 생각하는 머리를 길러야 한다.

* new로 할당받은 놈들은 초기화 반드시 해야한다.
* test case 별로, 시작지점에 변수 초기화.
* 포인터 파라미터에 대한 이해가 필요하다.
    * 포인터를 파라미터로 사용하고, 해당 변수를 조작해도 기존 포인터값은 변하질 않는다. (주소값을 담는 또하나의 주소공간을 보내는 것이기 때문)
    * 그렇게 하려면 pass by reference로 보내야 한다.
